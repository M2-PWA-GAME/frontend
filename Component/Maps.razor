@using frontend.Model
<h3>Maps</h3>

<div style="display: flex; align-items: center; justify-content: center;">
    <div class="map">
        <div style="display: grid; grid-template-columns: repeat(@Game.XMax, 1fr); width: @(32 * Game.XMax)">

            @for (int x = 0; x < Game.XMax; x++)
            {
                @for (int y = 0; y < Game.YMax; y++)
                {
                    <div style="grid-row: @(y + 1);">
                        <Tile X="x" Y="y" ActualTile="GetTileAt(x, y)" Game="Game" />
                    </div>
                }
            }

        </div>

        
        <div class="player" style="top: @(Game.PlayerCharacter.Y * 32)px; left: @(Game.PlayerCharacter.X * 32)px;" @onmouseover="MouseOverPlayer" @onmouseout="MouseOutPlayer">
            <img src="@Game.PlayerCharacter.CharacterImage" />
        </div>
    </div>
</div>

<div>
    <button class="btn btn-light" @onclick="Up">UP</button>
    <button class="btn btn-light" @onclick="Down">DOWN</button>
    <button class="btn btn-light" @onclick="Left">LEFT</button>
    <button class="btn btn-light" @onclick="Right">RIGHT</button>
    <button class="btn btn-light" @onclick="ToggleMoving">TOGGLE MOVING</button>
    @* <button @onclick="ToggleAttacking">TOGGLE ATTACKING</button> *@
    <button class="btn btn-light" @onclick="EndTurn">END TURN</button>
</div>

@code {
    [Parameter]
    public GameModel Game { get; set; }

    /// <summary>
    /// Method invoked when the component is ready to start, having received its
    /// initial parameters from its parent in the render tree.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Game.RefreshRequested += Game_OnRefreshRequested;
    }

    private void Game_OnRefreshRequested()
    {
        StateHasChanged();
    }

    public TileModel GetTileAt(int x, int y)
    {
        return Game.Tiles.FirstOrDefault(t => t.X == x && t.Y == y);
    }

    public void Up()
    {
        if (Game.PlayerCharacter.Y - 1 >= 0 && Game.PlayerCharacter.MouvementPoint > 0)
        {
            Game.PlayerCharacter.Y = Game.PlayerCharacter.Y - 1;
            Game.PlayerCharacter.Orientation = Orientation.UP;
            Game.PlayerCharacter.MouvementPoint--;
        }
    }

    public void Down()
    {
        if (Game.PlayerCharacter.Y + 1 < Game.YMax && Game.PlayerCharacter.MouvementPoint > 0)
        {
            Game.PlayerCharacter.Y = Game.PlayerCharacter.Y + 1;
            Game.PlayerCharacter.Orientation = Orientation.DOWN;
            Game.PlayerCharacter.MouvementPoint--;
        }
    }

    public void Left()
    {
        if (Game.PlayerCharacter.X - 1 >= 0 && Game.PlayerCharacter.MouvementPoint > 0)
        {
            Game.PlayerCharacter.X = Game.PlayerCharacter.X - 1;
            Game.PlayerCharacter.Orientation = Orientation.LEFT;
            Game.PlayerCharacter.MouvementPoint--;
        }
    }

    public void Right()
    {
        if (Game.PlayerCharacter.X + 1 < Game.XMax && Game.PlayerCharacter.MouvementPoint > 0)
        {
            Game.PlayerCharacter.X = Game.PlayerCharacter.X + 1;
            Game.PlayerCharacter.Orientation = Orientation.RIGHT;
            Game.PlayerCharacter.MouvementPoint--;
        }
    }

    private void MouseOverPlayer(MouseEventArgs obj)
    {
        Game.DisplayMovingRange();
    }

    private void MouseOutPlayer(MouseEventArgs obj)
    {
        Game.HideMovingRange();
    }

    private void ToggleMoving()
    {
        Game.ToggleMoving();
    }

    private void ToggleAttacking()
    {
        Game.ToggleAttacking();
    }

    private void EndTurn()
    {
        Game.PlayerCharacter.MouvementPoint = 3;
        Game.PlayerCharacter.IsInMovingMode = false;
    }

}

<img src="/img/Characters/MainCharacter/Character_32_DOWN.png" />
<img src="/img/Characters/MainCharacter/Character_32_LEFT.png" />
<img src="/img/Characters/MainCharacter/Character_32_RIGHT.png" />
<img src="/img/Characters/MainCharacter/Character_32_UP.png" />

